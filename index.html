<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IPC_SIM // SECURE_KERNEL</title>
    <style>
        :root {
            --bg: #e0e0e0;
            --border: 3px solid #000000;
            --shadow: 6px 6px 0px #000000;
            --red: #ff6b6b;
            --yellow: #feca57;
            --green: #1dd1a1;
            --blue: #54a0ff;
            --purple: #a29bfe;
            --mono: 'Courier New', Courier, monospace;
        }

        * {
            box-sizing: border-box;
            user-select: none;
        }

        body {
            margin: 0;
            padding: 20px;
            background-color: var(--bg);
            font-family: var(--mono);
            height: 100vh;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow: hidden;
        }

        header {
            background: white;
            border: var(--border);
            box-shadow: var(--shadow);
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
        }

        h1 {
            margin: 0;
            font-size: 24px;
            font-weight: 900;
            transform: skew(-5deg);
            background: black;
            color: white;
            padding: 5px 15px;
        }

        .btn-group {
            display: flex;
            gap: 10px;
        }

        button[title]:hover::after {
            content: attr(title);
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: black;
            color: white;
            padding: 5px;
            font-size: 10px;
            white-space: nowrap;
            pointer-events: none;
            margin-top: 5px;
            z-index: 200;
        }

        .layout {
            display: grid;
            grid-template-columns: 1fr 380px;
            gap: 20px;
            height: 100%;
            min-height: 0;
        }

        .kernel-space {
            background: white;
            border: var(--border);
            box-shadow: var(--shadow);
            position: relative;
            background-image: radial-gradient(#00000022 2px, transparent 2px);
            background-size: 20px 20px;
            overflow: hidden;
        }

        #wire-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        .kernel-node {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 150px;
            border: var(--border);
            border-radius: 15px;
            background: var(--blue);
            color: white;
            z-index: 5;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
            transition: transform 0.05s;
        }

        .kernel-header {
            border-bottom: 2px solid white;
            width: 100%;
            text-align: center;
            padding-bottom: 5px;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .buffer-container {
            width: 100%;
            flex-grow: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .buffer-container::-webkit-scrollbar {
            width: 0;
        }

        .msg-item {
            background: white;
            color: black;
            border: 2px solid black;
            font-size: 10px;
            padding: 3px;
            text-align: center;
            font-weight: bold;
            animation: slideIn 0.2s;
        }

        @keyframes slideIn {
            from {
                transform: translateY(10px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .node {
            position: absolute;
            width: 90px;
            height: 90px;
            border: var(--border);
            border-radius: 50%;
            background: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            z-index: 2;
            box-shadow: 4px 4px 0px rgba(0, 0, 0, 0.2);
        }

        .node.root {
            background: var(--red);
        }

        .node.user {
            background: var(--yellow);
        }

        .node.guest {
            background: var(--green);
        }

        .pid {
            background: black;
            color: white;
            padding: 2px 5px;
            font-size: 10px;
            position: absolute;
            bottom: -10px;
        }

        .overlay-icon {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 60px;
            z-index: 50;
            pointer-events: none;
            text-shadow: 4px 4px 0px black;
            animation: popFade 0.8s forwards;
        }

        @keyframes popFade {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 0;
            }

            20% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 1;
            }

            100% {
                transform: translate(-50%, -80%) scale(0.8);
                opacity: 0;
            }
        }

        .packet {
            position: absolute;
            width: 24px;
            height: 24px;
            background: black;
            border: 2px solid white;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            z-index: 20;
        }

        .packet-label {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--purple);
            border: 2px solid black;
            color: black;
            font-size: 10px;
            white-space: nowrap;
            padding: 2px 5px;
            font-weight: bold;
            box-shadow: 2px 2px 0px rgba(0, 0, 0, 0.2);
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
            z-index: 10;
            height: 100%;
            min-height: 0;
        }

        .panel {
            background: white;
            border: var(--border);
            padding: 15px;
            box-shadow: var(--shadow);
            flex-shrink: 0;
        }

        .panel-title {
            background: black;
            color: white;
            padding: 8px;
            text-align: center;
            font-weight: bold;
            margin: -15px -15px 15px -15px;
        }

        select,
        button {
            width: 100%;
            padding: 10px;
            border: 2px solid black;
            font-family: var(--mono);
            font-weight: bold;
            margin-bottom: 10px;
            cursor: pointer;
            position: relative;
        }

        .terminal {
            background: #111;
            color: #0f0;
            border: var(--border);
            flex-grow: 1;
            padding: 10px;
            font-size: 11px;
            overflow-y: auto;
            box-shadow: var(--shadow);
            min-height: 0;
            scroll-behavior: smooth;
        }

        .log-entry {
            margin-bottom: 4px;
            padding-left: 5px;
            border-left: 3px solid #555;
        }

        .log-err {
            color: #ff4757;
            border-left-color: #ff4757;
        }
    </style>
</head>

<body>

    <header>
        <h1>Message Passing IPC</h1>
        <div class="btn-group">
            <button onclick="sim.undo()" title="Undo (Ctrl+Z)"
                style="width:50px; font-size:18px; background:var(--yellow);">âŽŒ</button>
            <button onclick="sim.redo()" title="Redo (Ctrl+Y)"
                style="width:50px; font-size:18px; background:var(--yellow);">â†»</button>
            <button onclick="sim.reset()" title="Reset System"
                style="width:auto; background:var(--red); color:white;">RESET</button>
            <button onclick="window.location.href='./SharedMemory/index.html'" title="Open Shared Memory Sim"
                style="width:auto; background:var(--blue); color:white;">SHARED MEMORY</button>
        </div>
    </header>

    <div class="layout">
        <div class="kernel-space" id="kernelSpace">
            <canvas id="wire-layer"></canvas>
            <div style="position:absolute; top:20px; left:20px; pointer-events:none;">
                <u style="font-weight:bold;">ACL RULES</u>
                <div style="font-size:11px; margin-top:5px;">
                    <span style="color:var(--red)">â–  ROOT:</span> Full Access<br>
                    <span style="color:#f39c12">â–  USER:</span> No Root Access<br>
                    <span style="color:var(--green)">â–  GUEST:</span> Guest Only
                </div>
            </div>

            <div class="kernel-node" id="kernelNode">
                <div class="kernel-header">KERNEL BUFFER</div>
                <div class="buffer-container" id="bufferContainer">
                    <div style="opacity:0.5; font-size:10px; margin-top:10px;margin-left:60px">[EMPTY]</div>
                </div>
            </div>
        </div>

        <aside class="sidebar">
            <div class="panel">
                <div class="panel-title">CONTROL PANEL</div>
                <div style="display:flex; gap:5px;">
                    <select id="spawnType">
                        <option value="root">ROOT (Admin)</option>
                        <option value="user">USER (Standard)</option>
                        <option value="guest">GUEST (Restricted)</option>
                    </select>
                    <button onclick="sim.spawn()" style="width:50px; background:var(--yellow);">+</button>
                </div>
                <hr style="border:1px dashed #aaa; margin:15px 0;">
                <label style="font-size:10px;">SENDER</label>
                <select id="senderSelect"></select>
                <div style="text-align:center; font-size:14px; margin:-5px 0;">â†“</div>
                <label style="font-size:10px;">RECEIVER</label>
                <select id="receiverSelect"></select>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:10px;">
                    <button onclick="sim.send()" style="background:var(--green);">SEND â–¶</button>
                    <button onclick="sim.read()" style="background:white;">READ â—€</button>
                </div>
            </div>
            <div class="terminal" id="terminal">
                <div class="log-entry">[KERNEL] System Online.</div>
            </div>
        </aside>
    </div>

    <script>
        class Sim {
            constructor() {
                this.procs = [];
                this.buffer = [];
                this.pid = 100;

                // History only for user actions, not initial boot
                this.history = [];
                this.future = [];

                this.space = document.getElementById('kernelSpace');
                this.kernel = document.getElementById('kernelNode');
                this.bufUI = document.getElementById('bufferContainer');
                this.canvas = document.getElementById('wire-layer');
                this.ctx = this.canvas.getContext('2d');
                this.term = document.getElementById('terminal');

                window.addEventListener('resize', () => this.resize());

                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        if (e.key === 'z') { e.preventDefault(); this.undo(); }
                        if (e.key === 'y') { e.preventDefault(); this.redo(); }
                    }
                });

                // Initial permanent processes (not undoable)
                this.spawn('root', 'ROOT_SYS', false);
                this.spawn('user', 'USER_WEB', false);
                this.spawn('guest', 'GUEST_1', false);

                // Save initial state as base for undo/redo (but we never pop below this)
                this.saveState();

                this.resize();
                this.loop();
            }

            // Snapshot entire dynamic state
            snapshot() {
                return {
                    processes: this.procs.map(p => ({
                        id: p.id, name: p.name, type: p.type, x: p.x, y: p.y
                    })),
                    buffer: JSON.parse(JSON.stringify(this.buffer)),
                    pid: this.pid,
                    logHTML: this.term.innerHTML
                };
            }

            saveState() {
                this.history.push(this.snapshot());
                this.future = [];
                if (this.history.length > 50) this.history.shift();
            }

            restoreState(state) {
                this.pid = state.pid;
                this.buffer = state.buffer;
                this.term.innerHTML = state.logHTML;
                this.term.scrollTop = this.term.scrollHeight;

                // Remove all existing process nodes from DOM
                this.procs.forEach(p => { if (p.el) p.el.remove(); });

                // Rebuild processes + DOM
                this.procs = state.processes.map(pData => {
                    const el = document.createElement('div');
                    el.className = `node ${pData.type}`;
                    el.innerHTML = `<span>${pData.name}</span><div class="pid">${pData.id}</div>`;
                    this.space.appendChild(el);
                    return { ...pData, el };
                });

                this.placeNodes();
                this.renderBuf();
                this.updateUI();
            }

            undo() {
                if (this.history.length <= 1) return; // Keep earliest snapshot
                const current = this.history.pop();
                this.future.push(current);
                const prev = this.history[this.history.length - 1];
                this.restoreState(prev);
            }

            redo() {
                if (this.future.length === 0) return;
                const next = this.future.pop();
                this.history.push(next);
                this.restoreState(next);
            }

            spawn(type, name, record = true) {
                const t = type || document.getElementById('spawnType').value;
                const n = name || `${t.toUpperCase()}_${this.pid}`;
                const p = { id: this.pid++, name: n, type: t, el: null, x: 0, y: 0 };

                const el = document.createElement('div');
                el.className = `node ${t}`;
                el.innerHTML = `<span>${n}</span><div class="pid">${p.id}</div>`;
                this.space.appendChild(el);
                p.el = el;

                this.procs.push(p);
                this.placeNodes();
                this.updateUI();
                this.log(`Spawned ${n}`);

                if (record) this.saveState();
            }

            placeNodes() {
                const cx = this.space.clientWidth / 2;
                const cy = this.space.clientHeight / 2;
                const r = 240;
                const count = this.procs.length;

                this.procs.forEach((p, i) => {
                    const ang = Math.PI + (Math.PI * (i + 1) / (count + 1));
                    p.x = cx + Math.cos(ang) * r - 45;
                    p.y = cy + Math.sin(ang) * r * 0.6 - 45;
                    if (p.el) {
                        p.el.style.left = `${p.x}px`;
                        p.el.style.top = `${p.y}px`;
                    }
                });
            }

            check(s, r) {
                if (s.id === r.id) return "Loopback Error";
                if (s.type === 'root') return true;
                if (s.type === 'guest') return r.type === 'guest' ? true : "Guest Restricted";
                if (s.type === 'user') return r.type === 'root' ? "Root Protected" : true;
                return true;
            }

            send() {
                const sId = parseInt(document.getElementById('senderSelect').value);
                const rId = parseInt(document.getElementById('receiverSelect').value);
                if (!sId || !rId) return;

                const s = this.procs.find(p => p.id === sId);
                const r = this.procs.find(p => p.id === rId);

                if (s.id === r.id) {
                    this.triggerError('â›”');
                    this.log(`BLOCKED: Loopback Error`, 'err');
                    return;
                }

                this.anim(s, 'kernel', `TO: ${r.name}`, () => {
                    const perm = this.check(s, r);
                    if (perm === true) {
                        this.buffer.push({ from: sId, to: rId });
                        this.renderBuf();
                        this.log(`Msg Buffered for ${r.name}`);
                        this.saveState();
                    } else {
                        this.triggerError('â›”');
                        this.log(`BLOCKED: ${perm}`, 'err');
                    }
                });
            }

            read() {
                const sId = parseInt(document.getElementById('senderSelect').value);
                const rId = parseInt(document.getElementById('receiverSelect').value);
                if (!sId || !rId) return;

                if (sId === rId) {
                    this.triggerError('â›”');
                    this.log(`READ ERROR: Loopback not allowed`, 'err');
                    return;
                }

                const r = this.procs.find(p => p.id === rId);
                const idx = this.buffer.findIndex(m => m.to === rId && m.from === sId);

                if (idx === -1) {
                    this.triggerError('ðŸ“­');
                    this.log(`READ ERROR: No message from sender`, 'err');
                    return;
                }

                this.buffer.splice(idx, 1);
                this.renderBuf();
                this.saveState();

                this.anim('kernel', r, 'DATA', () => {
                    this.log(`Delivered to ${r.name}`);
                });
            }

            triggerError(icon) {
                const el = document.createElement('div');
                el.className = 'overlay-icon';
                el.innerHTML = icon;
                this.space.appendChild(el);
                setTimeout(() => el.remove(), 1000);

                let i = 0;
                const shake = setInterval(() => {
                    const offsetX = (i % 2 === 0 ? 5 : -5);
                    this.kernel.style.transform = `translate(calc(-50% + ${offsetX}px), -50%)`;
                    i++;
                    if (i > 6) {
                        clearInterval(shake);
                        this.kernel.style.transform = `translate(-50%, -50%)`;
                    }
                }, 40);
            }

            renderBuf() {
                this.bufUI.innerHTML = '';
                if (this.buffer.length === 0) {
                    this.bufUI.innerHTML = '<div style="opacity:0.5;font-size:10px;margin-top:10px;margin-left:60px">[EMPTY]</div>';
                    return;
                }
                this.buffer.forEach(m => {
                    const s = this.procs.find(p => p.id === m.from);
                    const r = this.procs.find(p => p.id === m.to);
                    if (s && r) {
                        const d = document.createElement('div');
                        d.className = 'msg-item';
                        d.innerHTML = `${s.name} â†’ ${r.name}`;
                        d.style.borderLeft = `4px solid ${r.type === 'root' ? 'red' : r.type === 'user' ? 'orange' : 'green'}`;
                        this.bufUI.appendChild(d);
                    }
                });
            }

            anim(from, to, text, cb) {
                const start = this.getPos(from);
                const end = this.getPos(to);

                const p = document.createElement('div');
                p.className = 'packet';
                p.innerHTML = 'âœ‰<div class="packet-label">' + text + '</div>';
                this.space.appendChild(p);

                const dur = 800;
                const t0 = performance.now();

                const step = (now) => {
                    const prog = Math.min((now - t0) / dur, 1);
                    const ease = prog < .5 ? 2 * prog * prog : -1 + (4 - 2 * prog) * prog;

                    const x = start.x + (end.x - start.x) * ease;
                    const y = start.y + (end.y - start.y) * ease;

                    p.style.left = (x - 12) + 'px';
                    p.style.top = (y - 12) + 'px';

                    if (prog < 1) requestAnimationFrame(step);
                    else {
                        p.remove();
                        if (cb) cb();
                    }
                };
                requestAnimationFrame(step);
            }

            getPos(obj) {
                if (obj === 'kernel') {
                    const r = this.kernel.getBoundingClientRect();
                    const s = this.space.getBoundingClientRect();
                    return { x: r.left - s.left + r.width / 2, y: r.top - s.top + r.height / 2 };
                }
                return { x: obj.x + 45, y: obj.y + 45 };
            }

            loop() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                const k = this.getPos('kernel');

                this.procs.forEach(p => {
                    const pc = this.getPos(p);
                    this.ctx.beginPath();
                    this.ctx.moveTo(k.x, k.y);
                    this.ctx.lineTo(pc.x, pc.y);
                    this.ctx.strokeStyle = '#00000020';
                    this.ctx.lineWidth = 3;
                    this.ctx.stroke();
                });
                requestAnimationFrame(() => this.loop());
            }

            updateUI() {
                const s = document.getElementById('senderSelect');
                const r = document.getElementById('receiverSelect');
                const sV = s.value; const rV = r.value;
                s.innerHTML = ''; r.innerHTML = '';
                this.procs.forEach(p => {
                    const opt = `<option value="${p.id}">${p.name}</option>`;
                    s.innerHTML += opt; r.innerHTML += opt;
                });
                if (sV) s.value = sV;
                if (rV) r.value = rV;
            }

            log(msg, type) {
                const c = type === 'err' ? 'log-err' : '';
                this.term.insertAdjacentHTML('beforeend', `<div class="log-entry ${c}">[${new Date().toLocaleTimeString()}] ${msg}</div>`);
                this.term.scrollTop = this.term.scrollHeight;
            }

            resize() {
                this.canvas.width = this.space.clientWidth;
                this.canvas.height = this.space.clientHeight;
                this.placeNodes();
            }

            reset() { location.reload(); }
        }

        const sim = new Sim();
    </script>
</body>

</html>